%\let\textcircled=\pgftextcircled
\chapter{Rotation with quaternions}
\label{chap:rotation_with_quaternions}

This chapter deals not only on usage of quaternions for rotations, but in general to all of the project part related to moving from a local frame of reference to laboratory one.

\section{From local to laboratory}
The program calculates the change of angular position by integrating angular velocities. The angular velocities are in a local reference frame, which means that for calculating angular position at time $t_{i+1}$ we must take in account angular position at time $t_i$. So angular position must be gradually composed.\\
% TODO insert image to explain cumulative rotation of vehicle
One of the first error I committed, is thinking the rotation composition as the sum of angles on each axis. I was using the same integration routine used for linear dimensions that does the cumulative sum on each axis, the sum of the areas. But when composing multiple rotations, for example when having a rotation around vertical versor $\hat{z}$ by an angle $\theta$, as well as adding $\theta$ to the vertical rotation, we must rotate rotation axis on the horizontal $xy$ plane. \\
So I divided the integration routine in two function, one that returns an array of areas, the second that calls the first and then does the cumulative sum of the array of areas. I've done this also for keeping compatibility for others module that were using the previous single function. \\
Then once i had the angle variation vector $<\Delta\theta_x,\Delta\theta_y,\Delta\Theta_z>$ the respective quaternion can be created and multiplied together. 
Essentially, all the two quaternion library used in the project overloads mathematical operators, in a way more or less explicit, so composition and rotation become more straightforward. \\
For quaternion composition, initially I was using \texttt{numpy.cumprod()} \cite{numpy-cumprod} but this function were doing multiplication in the opposite order respect to what I needed for quaternions. For example, calling \texttt{cumprod()} on a vector $<x,y,z,w>$ will result in $<x,xy,xyz,zyzw>$ while I needed 
$<x,yx,zyx,wzyx>$ \\
%TODO comparison with for cycle, proof that is faster
So I written some custom code to make quaternion composition using \texttt{functools.reduce()} as it's faster than using a \texttt{for} cycle.

\begin{lstlisting}[language=Python,frame=single,float,floatplacement=H]
quaternions = reduce(lambda array, element: [*array, element * array[-1]], 
					quaternions, 
					[initial_quaternion])
\end{lstlisting}
%TODO talk about how to create a quaternion, difference in creating a quaternion representing a rotation from one that represent a vector to be rotated.
%TODO also talk about map for rotation


\section{World frame of reference}
There exist and additional frame of reference, similar to the laboratory one described before but with a possible rotation in the horizontal plane. \\
This frame of reference have y-axis oriented towards geographical north and x-axis to east. \\
This is critically important for mixing GNSS data that is already in this frame of reference whit integrated inertial data. \\
To find the angle between GNSS positions and east the program find the first position that is at least 10 meters away from initial position, then calculates the angle of this position vector. \\
Assuming the first motion of the vehicle is forward, giving the previous calculated angle, all acceleration should be rotated. \\
Instead of rotating all accelerations and angular positions I only set correctly the initial position to be already aligned to the world frame of reference and because the following angular position are calculated from the first, no additional operations will be needed, saving the program to do a $O(n)$ operation, the rotation for all records.